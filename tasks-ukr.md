1. Напишіть функцію, яка буде валідувати рядок на правильне розташування різних дужок.
   Наприклад:
   aa[bb{cc}bb]aa — правильно
   aa[bb{cc]bb}aa — неправильно
   [aa{bb(cc)bb}aa] — правильно
   aabb[cc{bb}aa — неправильно

   **Рішення:**
   Потрібно використовувати стек. Якщо знаходите відкривальну дужку — кладете її у стек. Якщо закривальну — порівнюєте її з останнім елементом стека. Якщо це відповідна відкривальна дужка, видаляєте її зі стека.

2. Напишіть реалізацію алгоритму бінарного пошуку (binary search).

3. Є масив генераторів, дані в яких відсортовані за певною однією ознакою. Кількість об’єктів у генераторах різна і випадкова, кількість генераторів також випадкова. Потрібно створити новий генератор, у якому будуть усі об’єкти з тих генераторів, відсортовані за тією ж ознакою. При цьому не можна просто завантажити всі об’єкти в пам’ять — потрібно використати саме переваги генераторів.

   gen = [g1, g2, g3, ...]

4. Потрібно в масиві з додатними і від’ємними числами знайти підмасив із найбільшою сумою чисел. Таким підмасивом може бути і [].
   Наприклад:
   Якщо l = [−2, 1, −3, 4, −1, 2, 1, −5, 4], то потрібно повернути [4, −1, 2, 1] ⇒ 6

   **Рішення:**
   [https://medium.com/@rsinghal757/kadanes-algorithm-dynamic-programming-how-and-why-does-it-work-3fd8849ed73d](https://medium.com/@rsinghal757/kadanes-algorithm-dynamic-programming-how-and-why-does-it-work-3fd8849ed73d)

5. Напишіть метод, який повертатиме всі вузли на заданій глибині дерева

```
        1        | 0
       / \
      2   3      | 1
     / \    \
    4   6    8    | 2
   /   / \   / \
  5   7   9 10  11  | 3
```

Якщо глибина 3 — функція повинна повернути [5, 7, 9, 10, 11]
На глибині 1 — повинна повернути [2, 3]

**Рішення:**
Потрібно використовувати рекурсію.

6. Мережа складається з вузлів, пронумерованих від 0 до N. Вам надано список ребер (a, b, t), що описують час t, необхідний для передавання повідомлення від вузла a до вузла b. Коли вузол отримує повідомлення, він одразу передає його сусідньому вузлу, якщо це можливо. Припускаючи, що всі вузли з’єднані, визначте, скільки часу потрібно, щоб кожен вузол отримав повідомлення, яке починається з вузла 0.

   Наприклад, для N = 5 і таких ребер:

```
edges = [
    (0, 1, 5),
    (0, 2, 3),
    (0, 5, 4),
    (1, 3, 8),
    (2, 3, 1),
    (3, 5, 10),
    (3, 4, 5)
]
```

Потрібно повернути 9, оскільки передавання повідомлення шляхом 0 → 2 → 3 → 4 займе саме стільки часу.

**Примітка:** Є підозра, що наведений приклад може бути некоректним.

**Рішення:**
[https://dev.to/mxl/dijkstras-algorithm-in-python-algorithms-for-beginners-dkc](https://dev.to/mxl/dijkstras-algorithm-in-python-algorithms-for-beginners-dkc)

Рішення, запропоноване однією розумною людиною:

```
nodes = set([edge[0] for edge in edges] + [edge[1] for edge in edges])
distances = {0: 0}
while len(distances) != len(nodes):
    visited = set(distances.keys())
    calc_distance = lambda edge: distances[edge[0]] + edge[2]
    best = min(
        (edge for edge in edges if edge[0] in visited and edge[1] not in visited),
        key=calc_distance
    )
    distances[best[1]] = calc_distance(best)

print(max(distances.values()))
```
